-----------------------BigNumber-----------------------

#1.构造函数和属性：

构造函数 BigNumber(string s) 接受一个字符串参数，将字符串转换为大整数表示，存储在 bits 列表中。
属性 Length 返回大整数的位数。

#2.运算符重载：

重载了加法 +、减法 -、乘法 *、除法 /、取模 % 等运算符，实现了大整数的基本运算。

#2.1 加法 + 运算符重载

在 operator + 中，创建一个新的 BigNumber 对象 result 用于存储运算结果。
遍历两个大整数 bn1 和 bn2 中的每一位，相加，并将结果添加到 result 的 bits 列表中。
最后调用 Norminalize 方法规范化结果，处理进位等情况，确保结果正确。

#2.2 减法 - 运算符重载

在 operator - 中，创建一个新的 BigNumber 对象 result 用于存储运算结果。
确定被减数和减数，保证被减数大于等于减数，若不满足则进行交换。
遍历两个大整数 bn1 和 bn2 中的每一位，进行减法运算，并处理借位情况。
最后调用 Norminalize 方法规范化结果，确保结果正确，并根据需要设置结果为负数。

#2.3 乘法 * 运算符重载

在 operator * 中，创建一个新的 BigNumber 对象 result 用于存储运算结果。
初始化 result 的 bits 列表为零，并遍历两个大整数 bn1 和 bn2 的每一位进行乘法操作。
在内层循环中，将乘积添加到正确位置，并及时调用 Norminalize 方法处理进位情况。
最后再次调用 Norminalize 方法，确保结果正确。

#2.4 除法 / 运算符重载

在 operator / 中，创建一个新的 BigNumber 对象 result 用于存储运算结果，另外创建两个临时对象 remainder 和 divisor。
判断除数是否为零，若为零则抛出异常。
使用循环将被除数减去除数直到被除数小于除数，记录商并更新被除数。
将商添加到 result 的 bits 列表中，并保持规范化。

#2.5 取模 % 运算符重载

在 operator % 中，创建一个新的 BigNumber 对象 remainder 用于存储取模运算的结果。
判断除数是否为零，若为零则抛出异常。
使用循环将被除数减去除数直到被除数小于除数，最终得到余数。

#3.运算方法：

Norminalize(bool removeZeros) 方法用于规范化大整数，去除前导零。
operator * 实现大整数乘法，采用竖式乘法。
operator + 实现大整数加法。
operator - 实现大整数减法。
operator / 实现大整数除法。
operator % 实现大整数取模。

#4.比较方法：

重载了比较运算符 >=、<=、>、<、==、!=，用于比较两个大整数的大小和相等性。
通过重载比较运算符实现大整数的比较操作，包括大于、小于、等于等情况。

#5.ToString 方法：

重写 ToString 方法，将大整数转换为字符串表示，考虑了负数情况。

#6.Main 方法：

在 Main 方法中，创建两个大整数对象 bn1 和 bn2，进行加法、减法、乘法、除法和取模运算，然后输出结果。


-----------------------Sort-----------------------

Sort程序包含了多种排序算法的实现，包括选择排序、冒泡排序、插入排序、堆排序、希尔排序、计数排序、鸡尾酒排序和基数排序。

在 Main 方法中，程序创建了一个 Sort 对象，并生成一个包含500个随机整数的数组 complexArray，然后依次对这些排序算法进行测试和性能计时。

GenerateRandomArray 方法用于生成指定大小的随机整数数组。

TimeAndSort 方法用于计时并调用各个排序算法，并输出排序结果和运行时间。

每个排序算法都有对应的方法实现：

#1.选择排序 (SelectionSort):

思想：每次从未排序的部分选择最小的元素，放到已排序部分的末尾。

实现：遍历未排序部分，每次找到最小的元素，与未排序部分的第一个元素交换位置。

#2.冒泡排序 (BubbleSort):

思想：重复遍历待排序数组，依次比较相邻的元素，将最大（或最小）的元素交换至右端。

实现：从数组末尾开始，依次比较相邻元素，若逆序则交换位置，直至整个数组有序。

#3.插入排序 (InsertionSort):

思想：将待排序的元素插入到已经排序好的部分的正确位置。

实现：从未排序部分取出一个元素，与已排序部分比较并插入到正确位置。

#4.堆排序 (HeapSort):

思想：利用堆这种数据结构进行排序，构建最大堆/最小堆，然后依次取出堆顶元素。

实现：首先构建最大堆，然后每次取出堆顶元素与末尾元素交换，再重新调整堆结构。

#5.希尔排序 (ShellSort):

思想：将整个序列分割成若干个子序列，对子序列进行插入排序，最后整个序列基本有序再进行一次插入排序。

实现：选择一个增量序列，不断缩小增量，对每个子序列进行插入排序。

#6.计数排序 (CountingSort):

思想：统计每个元素出现的次数，根据元素的值确定其在输出序列中的位置。

实现：统计每个元素出现次数，计算每个元素在输出序列中的位置，一次遍历完成排序。

#7.鸡尾酒排序 (CocktailSort):

思想：类似冒泡排序，但是来回进行排序，先将最大元素移动到最右端，再将最小元素移动到最左端。

实现：依次从左向右和从右向左遍历数组，交换逆序的相邻元素，直到整个数组有序。

#8.基数排序 (RadixSort):

思想：根据元素的位数进行排序，从低位到高位依次按位排序。

实现：根据元素的位数进行计数排序，一次排序完成后，根据下一位再次排序，直至所有位数排序完成。


-----------------------Strassen-----------------------
#1. 代码结构

代码包含以下主要部分：

Main函数: 程序入口，定义矩阵、测试次数，调用两种算法进行测试，并打印结果和耗时。

GenerateRandomMatrix函数: 生成随机矩阵，用于测试算法。

ConventionalMatrixMultiplication函数: 实现常规矩阵乘法算法。

StrassenMatrixMultiplication函数: 实现Strassen矩阵乘法算法。

GetSubMatrix函数: 获取矩阵的子矩阵。

CombineSubMatrices函数: 合并子矩阵。

AddMatrices函数: 矩阵加法。

SubtractMatrices函数: 矩阵减法。

PrintMatrix函数: 打印矩阵 (可选，矩阵较大时不建议打印)。

#2. 算法实现

常规矩阵乘法算法: 使用三重循环，逐个计算结果矩阵的每个元素。时间复杂度为O(n^3)。

Strassen矩阵乘法算法:将矩阵递归地分成更小的子矩阵，直到子矩阵大小小于某个阈值。使用7次矩阵乘法和18次矩阵加减法来计算结果矩阵。时间复杂度为O(n^log2(7))，约为O(n^2.81)。

#3. 代码流程

初始化:

定义两个256x256的随机矩阵A和B。

可以选择使用预定义的矩阵进行测试，取消注释相应代码即可。

设置测试次数为10。

常规算法测试:

使用Stopwatch计时器记录常规算法的运行时间。

循环执行测试次数，计算平均耗时。

打印结果矩阵 (可选)。

Strassen算法测试:

使用Stopwatch计时器记录Strassen算法的运行时间。

循环执行测试次数，计算平均耗时。

打印结果矩阵 (可选)。

输出结果:

打印常规算法和Strassen算法的平均耗时。

#4. 代码特点

效率对比: 通过测试两种算法的运行时间，可以直观地比较它们的效率。

阈值设置: Strassen算法中设置了一个阈值，当子矩阵大小小于阈值时，使用常规算法进行计算。

递归实现: Strassen算法使用递归方式实现，将大矩阵分解成小矩阵进行计算。

代码注释: 代码中包含详细的注释，便于理解代码的功能和实现细节。

#5. 优化空间

阈值优化: 可以尝试不同的阈值，找到最佳的性能平衡点。

并行计算: 可以使用多线程或其他并行计算技术来加速Strassen算法。

数据结构优化: 可以使用更适合矩阵运算的数据结构，例如稀疏矩阵。

